---
title: Java 기술 면접 정리
toc: true
categories:	
    - Interview
tags:
- Java
last_modified_at: 
---



`Daily Update`

## JAVA

### JDK 1.8

- java1.8 은 java 8이라고 봐도된다.

### JAVA 8에 새로 추가된 것

- [Lamda 표현식](https://khj93.tistory.com/entry/JAVA-%EB%9E%8C%EB%8B%A4%EC%8B%9DRambda%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B4%EA%B3%A0-%EC%82%AC%EC%9A%A9%EB%B2%95)
- [Stream API](https://jeong-pro.tistory.com/165)

### SOLID 5원칙

- SRP(Single Responsibility Principle) : 단일 책임 원칙
  - 소프트웨어의 설계 부품(클래스, 함수 등)은 단 하나의 책임(기능)만 가져야한다.
  - 응집도는 높고 결합도는 낮게
  - 만약 한 클래스의 기능이 많아지면, 내부 함수끼리 강한 결합을 갖는다. 
    - 이는 유지보수에 많은 비용이 발생해 책임을 분리하는 것이 좋다.
- OCP(Open Closed Principle) : 개방 폐쇄 원칙
  - 기존의 코드를 변경하지 않고(Closed) 기능을 수정하거나 추가할 수 있도록(Open) 설계해야한다.
  - 확장에는 열려있고, 변경에는 닫혀있어야한다.
  - 기존 구성요소는 수정이 일어나지 말아야하며, 쉽게 확장이 가능해 재활용 가능해야한다.
  - **추상화**, **다형성**이 그 예시가 될 수 있다.
- LSP(Liskov Substitution Principle) : 리스코프 치환 원칙
  - 자식 클래스는 부모클래스에서 가능한 행위를 수행할 수 있어야한다.
  - 다시말해, 부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용해도 문제가 없어야 한다.
- ISP(Interface Segregation Principle) : 인터페이스 분리 원칙
  - 한 클래스는 자신이 사용하지 않는 인터페이스는 구현하지 말아야한다.
  - 다시말해, 자신이 사용하지 않는 기능(인터페이스)에는 영향을 받지 말아야한다.
  - 이러한 개념아래 **ISP**는 큰 덩어리의 인터페이스를 작은 단위로 분리 시켜 클라이언트가 필요하지 않은 인터페이스를 구현하지 않도록 하는 것이다.
  - 우리는 스마트폰으로 전화, 웹서핑, 사진 촬영 등 다양한 기능을 사용할 수 있다. 그런데 전화를 할 때에는 웹서핑, 사진촬영 등 다른 기능은 사용하지 않는다. 따라서 전화기능과 웹서핑 기능 사진 촬영 기능은 각각 독립된 인터페이스로 구현하여, 서로에게 영향을 받지 않도록 설계해야 한다.
- DIP(Dependency Inversion Principle) : 의존 역전 원칙
  - 의존 관계를 맺을 때, 변화하기 쉬운 것 보다 변화하기 어려운 것에 의존해야한다.
  - 여기서 변화하기 **쉬운** 것은 **구체화 된 클래스**
  - 변화하기 **어려운 것**은 **인터페이스**나 **추상클래스**를 의미한다.
  - 대표적인예로는 **의존성 주입**이있다.

#### Ref.

[SOLID 5 원칙](https://dev-momo.tistory.com/entry/SOLID-%EC%9B%90%EC%B9%99)

### 자바의 장점

- 별도 메모리 관리 필요없이 `Garbage Collector`에서 불필요한 메모리를 관리해준다.
- `JVM`을 통해 환경의 제약없이 활용할 수 있다.

### 객체지향(OOP)?

구현하고자 하는 대상을 하나의 객체로 바라보며 프로그래밍하는 기법이다. 객체에 상태와 행위를 부여하고, 이 객체들간의 상호작용을 통해 로직을 구현하는 프로그래밍 패러다임 중 하나이다.

### 객체지향의 장/단점

#### 장점

- 코드의 재사용성

이미 만들어 놓은 객체를 마치 조립을 하듯이 갈아끼울 수 있다. 재사용성이 높아진다.

- 대규모의 프로젝트에 적합하다.

객체 단위로 분류해서 담당하는 부분만 개발하고, 개발이 이루어진 후 객체들간의 관계만 설정해주면 되기때문에 대규모의 프로젝트에서 업무를 분담하여 개발하기 쉽다.

- 유지보수가 쉽다.

절차지향같은 경우에는 코드를 수정할 때, 해당 부분을 직접찾아 수정해야하는 불편함이있지만,
객체지향은 수정하고자하는 객체 내부의 클래스 변수나 메소드를 수정해주면 되기때문에
유지보수에 장점이있다.

#### 단점

- 절차지향보다 속도가 느리다.
- 설계에 많은 시간이 투자된다.

### OOP 4대 특징

- 추상화

불필요한 정보들은 숨기고 **공통의 속성이나 기능**을 묶어놓은 것 (EX. 카트라이더 - 기본 카트)
다시말하면, 객체지향 관점에서 클래스를 정의하는 것

동일한 메소드를 가진 서브 클래스 여러개를 만들기위해서 사용한다.

- 캡슐화

캡슐화의 주요 목적은 중요한 데이터를 **보존, 보호**이다.

```
캡슐화는 api를 사용하는 "클라이언트" 입장에서 생각하면 됩니다.
클라이언트가 커피머신을 이용한다고 가정할 때,
"코드 꼽고, 물 넣고, 원두 채우고, ... , 만약 커피 찌꺼기가 있으면 비우고, 
..., 아메리카노 내리는 버튼 누르기" 보다 
그냥 "아메리카노 한잔 내려" 라고 하는 게 원래 의도겠죠.
```

[[출처] Okky](https://okky.kr/article/653658)

- 상속

기존의 클래스의 기능을 **확장**하거나 **수정**할 수 있는 객체지향의 특성을 가장 잘 나타내는 요소 중 하나이다. 상속을 통해 코드의 중복을 줄이고, 유지보수성을 높일 수 있다.

- 다형성

하나의 변수명, 함수명 등이 상황에 따라 **다른 의미로 해석**될 수 있는 것을 뜻함
다형성의 예로는 **오버로딩**, **오버라이딩**이 있다.

### 인터페이스

- 공통적으로 개발해야 할 기능이나 규격 등의 구현을 **강제**하는 역할을 한다.
- **동일한 목적 하에 동일한 기능을 보장하게 하기 위함!**
- 코드의 수정을 줄이고, 유지보수성을 높일 수 있다.

-  `interface` -> `interface` 상속 가능
- `interface` -> `객체` `implements`로 반드시 구현 

### "==" 과 "equals" 차이

- "==" : 주소값을 비교한다. 만약 같은 값을 가지고 있어도 참조하고 있는 주소값이 다르다면 `false`를 리턴한다. (등호)
- "equals" : 단순히 값만을 비교한다. 

```java
String s1="Cat";
String s2="Cat";
String s3=new String("Cat");

System.out.println(s1==s2); // true
System.out.println(s1.equals(s2)); // true
System.out.println(s1==s3); // false
System.out.println(s1.equals(s3)); // true
```

![string pool](https://user-images.githubusercontent.com/49560745/107731916-6da51c00-6d3a-11eb-8189-e6b459e9c0f8.png)

- 리터럴 `""`으로 생성한 `String`은 `Stirng Pool`에 저장된다.
  - 이미 같은 문자열로 생성된 값이 있다면 같은 값을 참조한다.
  - 따라서, `==` 키워드로 비교시 같은 문자열이라면 `true`를 반환한다.
- `new` 연산자를 통해 생성한 `String`은 `Heap` 영역에 저장된다.

#### Ref.

[String vs StringBuilder vs StringBuffer](https://gwang920.github.io/java/stringType/)

https://richong.tistory.com/122

### Call by Value vs Call by Reference

- `Java`는 기본적으로 `Call by Value` 이다.

- `pimitive type`이 아닌 것에 대해서는 `call by reference`와 유사한 효과를 취하게 될 뿐이다.

[Call by value vs Call by reference](https://gwang920.github.io/java/CallbyValue-CallbyReference/)

### Collection

```
컬렉션이란 객체의 그룹을 조작하고 저장할 수 있는 자료구조이다.  
Java Collection 같은 경우 같은 타입의 자료를 관리할 수 있는 
유용한 하위 인터페이스들의 집합이다. 
```

### 메모리 구조

![image](https://user-images.githubusercontent.com/49560745/108475972-ce050200-72d4-11eb-98a6-37b7e71021b9.png)

#### Ref.

[자바 JVM 메모리구조](https://m.blog.naver.com/PostView.nhn?blogId=kywpcm&logNo=30170981872&proxyReferer=https:%2F%2Fwww.google.com%2F)

### 원시타입 vs 참조타입

- 원시 타입은 `null`을 담을 수 없다. 반면에 참조 타입은 `null`을 담을 수 있다.
- 원시 타입은 제네릭 타입에서 사용할 수 없다. 반면 참조 타입은 제네릭 타입에서 사용할 수 있다.

**그럼 원시 타입의 장점은?**

- 접근 속도
  - **원시타입 > 참조타입**
  - 원시 타입은 항상 `stack`영역에 담긴다.
  - 참조 타입은 `stack`영역에는 참조 값만 있고 실제 값은 `heap`영역에 담긴다. 그리고 값이 필요할 때마다 언박싱 과정을 거쳐야해서 접근속도가 느리다.
- 차지하는 메모리양
  - 차지하는 메모리양도 참조타입이 훨씬 많다.

### super

- 자식 클래스가 부모 클래스로부터 상속받은 멤버들을 참조할 때 사용하는 참조변수이다.
- 부모 클래스와 자식 클래스의 멤버 이름이 같을 때 `super`를 사용해 접근할 수 있다.

### JVM(Java Virtual Machine)

- `OS`에 구애받지 않고 동작한다.
- `JVM`은 자바의 바이트 코드를 실행할 수 있게 해주는 주체이며, `OS` 뿐만 아니라 `CPU(32 비트,64 비트)`에도 구애받지 않고 동작한다.

### 환경변수

- 운영체제가 참고하는 변수
  - 운영체제란 하드웨어를 사용할 수 있게끔 해주는 프로그램
  - 운영체제가 없으면 하드웨어에 애플리케이션을 올릴 수 없다.
- `JDK`는 개발과 실행이 가능한 디렉토리, `JRE`는 실행만 가능한 디렉토리
- 개발을 위해 `JDK`를 환경변수에 설정해줘야함
- `bin`에 실행파일 있기 때문에 `bin` 경로로 환경변수를 설정해야함

### 환경변수 설정 이유?

- 운영체제가 컴퓨터의 어떤 경로에서든 특정파일을 인식할 수 있도록 환경변수를 등록하는 것

### Block/NonBlock, Sync/Async

#### Blocking/NonBlocking

- 호출되는 함수가 바로 리턴하느냐 마느냐가 관심사이다.
- 호출된 함수가 바로 리턴해서 호출한 함수에게 제어권을 넘겨주고, 호출한 함수가 다른 일을 할 수 있는 기회를 줄 수 있다면 **NonBlocking**이다.

- 호출된 함수가 자신의 작업을 모두 마칠 때까지 호출한 함수에게 제어권을 넘겨주지 않고 대기하게 만든다면 **Blocking**이다.

#### Synchronous/Asynchronous

- 호출되는 함수의 작업 여부를 누가 신경쓰느냐가 관심사이다.
- 이전에 호출된 함수의 끝과 시작 될 함수의 타이밍이 맞을 때를 **Synchronous**라고 한다.
- 순차적으로 실행이 이루어지지 않으면 **Asynchronous**이다.

### POJO

- 특정 **기술**에 종속되어 동작하는 것이 아닌 순수한 자바 객체를 말한다.
  - 특정 기술과 환경에 종속되어 의존하게 된 자바코드는 가독성이 떨어져 유지보수에 어려움이 생겼다. 
  - 특정 기술의 클래스를 상속받거나 직접 의존하게 되어 확장성 또한 매우 떨어졌다.

이러한 문제점을 해결하기 위해 **POJO**라는 개념이 등장했다. 오래된 방식의 순수한 자바객체를 뜻한다.

#### Ref.

[POJO](https://siyoon210.tistory.com/120)